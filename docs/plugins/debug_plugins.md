# Debugging during plugin development

When developing plugins in napari, you may encounter mistakes or bugs in your code. This page covers some ways to debug napari plugins during development, including:

1. Debugging plugin start-up issues.
2. Seeing plugin errors and warnings.
3. Debugging plugin functionality.
4. Reloading code during plugin development.
5. Isolating issues from napari.
6. Logging and debug messages.

## Debugging plugin start-up issues

It is possible that after installing your plugin, napari will fail to launch - or your plugin won't show up. 
The following commands will report any issues napari detects with your plugin that may prevent napari from launching or prevent napari from discovering your plugin:

* `napari --plugin-info -v` - prints installed napari plugins, what they provide, and any issues related to these plugins.
* `napari --info` - prints key environment information related to napari, and the version of installed plugins.
* `npe2 validate YOUR_PLUGIN_NAME` - ensures that your plugin has a valid manifest file.

```{note}
In general, `napari --info` is a good first step to debugging any environment issues and providing the output from this command is useful when raising bugs.
```

## Seeing plugin errors and warnings

Once the plugin has been successfully loaded, you can view any warnings or errors related to the plugin from the napari viewer menu bar at `Plugins -> Plugin Errors... -> <YOUR_PLUGIN_NAME>`. If your plugin name does not show in the list, then there are no errors related to your plugin at start up. During plugin execution, some errors or warnings related to your plugin may also be reported here.

### Seeing tracebacks from plugin errors

By default, napari will output any traceback information from plugin related errors to the console or jupyter notebook that napari was launched from.
Additionally, a popup will show in the bottom right corner of the napari viewer with a `View Traceback` button.
Inside of this popup, the full traceback can be seen, along with the option to drop into the debugger from here.
Dropping into the debugger will open the built in [python debugger](https://docs.python.org/3/library/pdb.html) at the point of failure.

You can also set napari not to catch error messages, or set napari exit on error via the following environment variables, respectively:

```sh
NAPARI_CATCH_ERRORS=0 
NAPARI_EXIT_ON_ERROR=1
```

## Overview of methods to debug plugins during development

### Reload code as you change it with IPython

Reloading code as it changes with IPython provides an easy way to see the immediate impacts of code development without the need to relaunch the viewer multiple times.

### Write a script to setup the plugin without user interaction

Writing a setup script reproducibly places your napari viewer at the state of problems, without having to perform user interaction in the GUI to get back to the problem state.

### Isolate the plugin functionality from napari

Since napari plugins are just Python functions, it can be easiest to isolate the issues from napari in some circumstances. For example, in the case of a widget, the widget could be isolated from napari and run separately as a PyQt widget for debugging purposes. In this way, the usual debugging tools, such as those provided by an IDE, can be applied. This method has the additional benefit of aligning with test driven development.

## A simple plugin for following examples

To demonstrate these debugging options, we will create a small plugin that prints the text entered into a box by the user. The plugin will provide an autogenerated widget, a `magic_factory` widget, and a `QWidget` - see the [contribution guides](./guides.md#widgets) for more detail. Below is the plugin file structure and contents. Create this structure, and fill the files with the below information.

### Plugin contents

```
# project structure
~/napari-simple-reload/
├── napari_simple_reload/
│   ├── __init__.py
│   ├── napari.yaml
│   └── _widget.py
├── pyproject.toml
├── setup.cfg
```

```TOML
# pyproject.toml
[build-system]
requires = ["setuptools>=42.0.0", "wheel"]
build-backend = "setuptools.build_meta"
```

```YAML
# napari_simple_reload/napari.yaml
name: napari-simple-reload
display_name: Simple reload
contributions:
  commands:
    - id: napari-simple-reload.example
      python_name: napari_simple_reload._widget:example
      title: Example autogenerated to test reloading
    - id: napari-simple-reload.example_factory
      python_name: napari_simple_reload._widget:example_factory
      title: Example factory to test reloading
    - id: napari-simple-reload.example_widget
      python_name: napari_simple_reload._widget:ExampleQWidget
      title: Example QWidget to test reloading
  widgets:
    - command: napari-simple-reload.example
      display_name: Autogenerated
      autogenerate: true
    - command: napari-simple-reload.example_factory
      display_name: Factory
    - command: napari-simple-reload.example_widget
      display_name: QWidget
```

```Python
# napari_simple_reload/_widget.py
from magicgui import magic_factory
from qtpy.QtWidgets import QVBoxLayout, QPushButton, QWidget, QLineEdit

def example(input_string: str) -> str:
    output_string = f"You entered {input_string}!"
    print(output_string)
    return output_string

@magic_factory
def example_factory(input_string: str) -> str:
    return example(input_string)

class ExampleQWidget(QWidget):
    def __init__(self):
        super().__init__()
        btn = QPushButton("Run")
        btn.clicked.connect(self._on_click)
        text_box = QLineEdit()
        self.setLayout(QVBoxLayout())
        self.layout().addWidget(text_box)
        self.layout().addWidget(btn)

    def _on_click(self):
        example(self.layout().itemAt(0).widget().text())
```

``` INI
# setup.cfg
[metadata]
name = napari-simple-reload

[options]
packages = find:
install_requires = 
    magicgui
include_package_data = True

[options.entry_points]
napari.manifest = 
    napari-simple-reload = napari_simple_reload:napari.yaml

[options.package_data]
* = *.yaml
```

Then install the package by:

```bash
cd napari-simple-reload
pip install -e .
```

## Using IPython to reload code during plugin development

Here, we demonstrate using the [autoreload extension](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) with IPython or a Jupyter notebook to open the napari viewer with the ability to reload the changed plugin code during development.

### Launch IPython and set up the viewer

First, we open the napari viewer and add our three plugin widgets to the dock. Launch IPython via the `IPython` command in terminal (IPython is installed with napari) and then enter the following into the IPython console:

```IPython
In [1]: %load_ext autoreload

In [2]: %autoreload 2

In [3]: from napari import Viewer

In [4]: from magicgui import magicgui

In [5]: viewer = Viewer()

In [6]: from napari_simple_reload._widget import example

In [7]: viewer.window.add_plugin_dock_widget(
    "napari-simple-reload", "Autogenerated")

In [8]: viewer.window.add_plugin_dock_widget(
    "napari-simple-reload", "Factory")

In [9]: viewer.window.add_plugin_dock_widget(
    "napari-simple-reload", "QWidget")
```

### Changing the code with IPython running

Currently, clicking on the run button for any of these widgets in the napari viewer outputs "You entered **YOUR_ENTRY**!". However, we would like to change the behaviour such that a special message is printed if nothing is entered. So let's change our `example` function to:

```Python
def example(input_string: str) -> str:
    output_string = (
        f"You entered {input_string}!"
        if input_string
        else "Please enter something in the text box."
    )
    print(output_string)
    return output_string
```

Notice how the widgets in the viewer currently have the same behaviour as before, despite the code update. This is because the code won't immediately update, as IPython does not yet know that it should update that code. To trigger the code update, just type the name of your changed function into IPython, or reference it in some way:

```IPython
# Run before changing the code
You entered !

# Run after changing the code, but before triggering an update
You entered !

In [10]: example # anything in IPython to reload that code

# Now the code is reloaded, run outputs as expected
Please enter something in the text box.
```

## Write a setup script to avoid GUI interaction

The key here is to use `viewer.window.add_plugin_dock_widget()` and then programmatically add the required information to your plugin so that when napari is launched, it launches with the required information to reproduce the problem, without having to click through the UI each time.
To continue with the example plugin shown in the last step, we want to make sure we have no sneaky bugs if the user enters text such as None, 0, or False (which all evaluate to False in Python when converted to a bool). Let's create a setup script `reproduce_issue.py` and check this for the autogenerated widget:

```Python
# reproduce_issue.py
from napari import Viewer, run

viewer = Viewer()
dw, my_widget = viewer.window.add_plugin_dock_widget(
    "napari-simple-reload", "Autogenerated"
)
values_to_test = [False, 0, None]
for value in values_to_test:
    my_widget.input_string.value = value
    my_widget()

run()

# Output is:
# You entered False!
# You entered 0!
# You entered None!
```

Running `python reproduce_issue.py` will run our widget for the inputs `False, 0, None`. The output shows that there are no sneaky bugs, but notice how the viewer remains at the state of the last entered value of None in the text box in the GUI. This same idea can be used to set up the GUI to a point of failure without having to manually input all the user interactions - and can help better identify the issue.

## Isolate the issue from napari

This solution ties in with the idea of test-driven development (see the [napari testing guidelines](./test_deploy.md#prefer-smaller-unit-tests-when-possible)). The idea is to trust that napari will provide the information you expect it to, and test your widgets independently of the viewer. In the case above, to verify that some input values work as expected, it would be like so:

```Python
# test_print.py
from napari_simple_reload._widget import example_factory

def test_false_inputs():
    values_to_test = [False, 0, None]
    for value in values_to_test:
        wdg = example_factory(input_string={"value": str(value)})
        result = wdg()
        assert result == f"You entered {value}!"
    
if __name__ == "__main__":
    test_false_inputs()
```

Then, for `python test_print.py` you can use any of your usual debugging tools - such as the visual debugger provided by a Python IDE (e.g. PyCharm, VSCode, or Spyder). Further, an isolated test like this can be integrated into a [testing suite for your napari plugin](https://napari.org/stable/plugins/test_deploy.html).

## Logging and user messages in napari

### Set up plugin user messages and notifications

There are, generally speaking, three main methods for notifying users of problems in napari.

1. Raise an exception to indicate a breaking problem in the code (e.g. unexpected user input `raise ValueError("some error")`).
2. Indicate that something that was handled, but may not be the behaviour the user was expecting using `warnings.warn("some warning")`.
3. Show an information popup in the napari GUI by using the `napari.utils.notifications.show_info("message")` command.

### Set up plugin log messages

In addition to these user focused methods, you can set up plugin debug logs and messages during development. You can either use [napari specific functions](https://napari.org/dev/api/napari.utils.notifications.html), or [built in Python logging](https://docs.python.org/3/library/logging.html).

```{tip}
A logging library, like [loguru](https://github.com/Delgan/loguru), can be easier to get started with than the built in Python logging library.
```

Below is an example of establishing debug messages and logs in your code and viewing them in napari by setting the preferences for GUI notifications and console notifications to be at the debug level. We modify the example function from before to have a debug log message:

```Python
import logging
import sys
from napari.utils.notifications import (
    notification_manager,
    Notification,
    NotificationSeverity,
    show_console_notification,
)

my_plugin_logger = logging.getLogger("napari_simple_reload")
stdout_handler = logging.StreamHandler(sys.stderr)
stdout_handler.setFormatter(
    logging.Formatter(
        fmt="%(levelname)s: %(asctime)s %(message)s",
        datefmt="%d/%m/%Y %I:%M:%S %p"
    )
)
my_plugin_logger.addHandler(stdout_handler)
my_plugin_logger.setLevel(logging.WARNING)

def show_debug(message: str):
    """
    Show a debug message in the notification manager.
    """
    notification_ = Notification(
        message, severity=NotificationSeverity.DEBUG)
    # Show message in the console only ->
    show_console_notification(notification_)
    # Show message in console and the napari GUI ->
    notification_manager.dispatch(notification_)
    # Control level of shown messages via napari preferences

def example(input_string: str) -> str:
    output_string = (
        f"You entered {input_string}!"
        if input_string
        else "Please enter something in the text box."
    )
    show_debug(f"The input string was (napari): {input_string}")
    my_plugin_logger.debug(
        f"The input string was (logging): {input_string}")
    print(output_string)
    return output_string
```

### Viewing plugin log messages

Launch the viewer with the napari notification levels set to debug and your plugin logger level set to debug:

```Python
# example_notication.py
import logging
from napari.settings import get_settings
from napari import run, Viewer

settings = get_settings()
settings.application.console_notification_level = "debug"
settings.application.gui_notification_level = "debug"
viewer = Viewer()
viewer.window.add_plugin_dock_widget(
  "napari-simple-reload", "Autogenerated"
)
logging.getLogger("napari_simple_reload").setLevel(logging.DEBUG)
run()
```

Running this script with `python example_notification.py` and entering fast into the input text box and clicking run you should then see:

```txt
DEBUG: The input string was (napari): fast
# A GUI notification of the same
DEBUG: The input string was (napari): fast
DEBUG: 20/09/2022 05:59:23 PM The input string was (logging): fast
You entered fast!
```
